<HTML><HEAD></HEAD><BODY>
<!--  sekey --- 'se' cursor key guide                             29/11/1988 -->
<!--  -->
<!--  -->
<H1 ALIGN=CENTER>Screen Editor Cursor Control Keys</H1>
The set of control characters defined below can be used for correcting
mistakes while typing regular editing commands, for correcting commands
that have caused an error message to be displayed, for correcting lines
typed in append mode, or for inline editing using the &#145;<TT>v</TT>&#146; command
described in the commands section.
<P>
<B>Se</B>
provides key binding, that is,
the ability to for a user to reassign the meanings of the control keys.
Therefore, the list of control keys given below is merely the default
for the editor when no keys have been reassigned.
<P>
In fact, it is quite possible to arrange for a single key to
generate a commonly used word or phrase as well as to invoke special
built-in functions such as the date and time functions.
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>Binding</TD><TD ALIGN=CENTER>Function</TD><TD ALIGN=CENTER>Action</TD>
</TR>
</TABLE>
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>CTRL_A</TD><TD ALIGN=CENTER>toggle_insert_mode</TD><TD ALIGN=CENTER>Toggle insert mode</TD>
</TR>
</TABLE>
The status of the insertion indicator is inverted.
<!--  Who wrote this ? NASA ? -->
Insert mode, when enabled, causes characters typed to be
inserted at the current cursor position in the line
instead of overwriting the characters that were there previously.
When insert mode is in effect, &#145;<TT>INSERT</TT>&#146; appears
in the status line.
If the terminal is able to, the
shape of the cursor is changed when in insert mode.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>CTRL_B</TD><TD ALIGN=CENTER>g_scan_right</TD><TD ALIGN=CENTER>Scan right and erase</TD>
</TR>
</TABLE>
The current line is scanned from the current
cursor position to the right margin until an occurrence of the
next character typed is found.
When the character is found,
all characters from the current cursor position up to (but not including)
the scanned character are deleted and the remainder of the line
is moved to the left to close the gap.
The cursor is left in the same column which is now occupied by the
scanned character.
If the line to the right of the cursor does not contain the character
being sought, the
terminal's bell is sounded
and the message &#145;<TT>NOCHAR</TT>&#146; appears in the status line.
<B>Se</B>
remembers the last character that was scanned using this
or any of the other scanning keys;
if control-b is hit twice in a row, this remembered character is
used instead of a literal control-b.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>CTRL_C</TD><TD ALIGN=CENTER>insert_blank</TD><TD ALIGN=CENTER>Insert blank</TD>
</TR>
</TABLE>
The characters at and to the right of
the current cursor position are moved to the right one column
and a blank is inserted to fill the gap.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>CTRL_D</TD><TD ALIGN=CENTER>up</TD><TD ALIGN=CENTER>Cursor up</TD>
</TR>
</TABLE>
The effect of this key depends on
<B>se</B>'s
current mode.
When in command mode, the current line pointer is moved
to the previous line without affecting the contents of the command line.
If the current line pointer is at line 1, the last line
in the file becomes the new current line.
In overlay mode (viz. the &#145;<TT>v</TT>&#146; command), the cursor is
moved up one line while remaining in the same column.
In append mode, this key is ignored.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>CTRL_E</TD><TD ALIGN=CENTER>tab_left</TD><TD ALIGN=CENTER>Tab left</TD>
</TR>
</TABLE>
The cursor is moved to the nearest tab stop to the left
of its current position.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>CTRL_F</TD><TD ALIGN=CENTER>funny</TD><TD ALIGN=CENTER>Funny return</TD>
</TR>
</TABLE>
The effect of this key depends on the editor's current mode.
In command mode, the current command line is entered as-is,
but is not erased upon completion of the command;
in append mode, the current line is duplicated;
in overlay mode (viz. the &#145;<TT>v</TT>&#146; command),
the current line is restored to its original state and command mode
is reentered (except if under control of a global prefix).
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>CTRL_G</TD><TD ALIGN=CENTER>right</TD><TD ALIGN=CENTER>Cursor right</TD>
</TR>
</TABLE>
The cursor is moved one column to the right.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>CTRL_H</TD><TD ALIGN=CENTER>left</TD><TD ALIGN=CENTER>Cursor left</TD>
</TR>
</TABLE>
The cursor is moved one column to the left.
Note that this <U>does not</U> erase any characters;
it simply moves the cursor.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>CTRL_I</TD><TD ALIGN=CENTER>tab_right</TD><TD ALIGN=CENTER>Tab right</TD>
</TR>
</TABLE>
The cursor is moved to the next tab stop to the right of its current
position.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>CTRL_J</TD><TD ALIGN=CENTER>scan_right</TD><TD ALIGN=CENTER>Scan right</TD>
</TR>
</TABLE>
This key is identical to the control-l key described below,
except that the scan proceeds to the right from
the current cursor position.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>CTRL_K</TD><TD ALIGN=CENTER>down</TD><TD ALIGN=CENTER>Cursor down</TD>
</TR>
</TABLE>
As with the control-d key,
this key's effect depends on the current editing mode.
In command mode, the current line pointer is moved to the next
line without changing the contents of the command line.
If the current line pointer is at the last line in the file,
line 1 becomes the new current line.
In overlay mode (viz. the &#145;<TT>v</TT>&#146; command),
the cursor is moved down one line while remaining in the same column.
In append mode, control-K has no effect.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>CTRL_L</TD><TD ALIGN=CENTER>scan_left</TD><TD ALIGN=CENTER>Scan left</TD>
</TR>
</TABLE>
The cursor is positioned according to the character
typed immediately after the control-l.
In effect, the current line is scanned, starting from the current
cursor position and moving left,
for the first occurrence of this character.
If none is found before the beginning of the line is reached,
the scan resumes with the last character in the line.
If the line does not contain the character being looked for, the
terminal's bell is sounded
and the message &#145;<TT>NOCHAR</TT>&#146; appears in the status line.
<B>Se</B>
remembers the last character that was scanned for using this key;
if the control-l is hit twice in a row, this remembered character
is searched for instead of a literal control-l.
Apart from this, however,
the character typed after control-l is taken literally, so
<B>se</B>'s
case conversion feature does not apply.
<!--  .KD "CTRL_M" "[Enter]" "Newline" -->
<!--  This key is identical to the NEWLINE key described below. -->
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>CTRL_M</TD><TD ALIGN=CENTER>enter</TD><TD ALIGN=CENTER>Kill right and terminate</TD>
</TR>
</TABLE>
The characters at and to the right of the current cursor position
are deleted, and the line is terminated.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>CTRL_N</TD><TD ALIGN=CENTER>g_scan_left</TD><TD ALIGN=CENTER>Scan left and erase</TD>
</TR>
</TABLE>
The current line is scanned from the current cursor position to the
left margin until an occurrence of the next character typed is found.
Then that character and all characters to its right up to
(but not including) the character under the cursor are erased.
The remainder of the line, as well as the cursor are moved to the
left to close the gap.
If the line to the left of the cursor does not contain
the character being sought, the
terminal's bell is sounded
and the message &#145;<TT>NOCHAR</TT>&#146; appears in the status line.
As with the control-b key, if control-n is hit twice in a row,
the last character scanned for is used instead of a literal control-n.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>CTRL_O</TD><TD ALIGN=CENTER>end</TD><TD ALIGN=CENTER>Skip right</TD>
</TR>
</TABLE>
The cursor is moved to the first position beyond the current end of line.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>CTRL_P</TD><TD ALIGN=CENTER>identify</TD><TD ALIGN=CENTER>Identify Bindable Keys</TD>
</TR>
</TABLE>
Press it and find out.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>CTRL_Q</TD><TD ALIGN=CENTER>page_up</TD><TD ALIGN=CENTER>Page up</TD>
</TR>
</TABLE>
This key does the same thing as the &#147;page backwards&#148; command,
&#145;<TT>p</TT>&#146;, but works in overlay mode as well as command mode.
The window is moved backward in the file to display the
previous screenful.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>CTRL_R</TD><TD ALIGN=CENTER>del_right</TD><TD ALIGN=CENTER>Erase right</TD>
</TR>
</TABLE>
The character at the current cursor position is erased and
all characters to its right are moved left one position.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>CTRL_S</TD><TD ALIGN=CENTER>page_down</TD><TD ALIGN=CENTER>Page down</TD>
</TR>
</TABLE>
This key does the same thing as the &#147;page forwards&#148; command,
&#145;<TT>:</TT>&#146;, but works in overlay mode as well as command mode.
The window is moved forward in the file to display the next screenful.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>CTRL_T</TD><TD ALIGN=CENTER>kill_right</TD><TD ALIGN=CENTER>Kill right</TD>
</TR>
</TABLE>
The character at the current cursor position and all those to its right
are erased.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>CTRL_U</TD><TD ALIGN=CENTER>del_left</TD><TD ALIGN=CENTER>Erase left</TD>
</TR>
</TABLE>
The character to the left of the current cursor position is deleted
and all characters to its right are moved to the left to fill the gap.
The cursor is also moved left one column,
leaving it over the same character.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>CTRL_V</TD><TD ALIGN=CENTER>t_skip_right</TD><TD ALIGN=CENTER>Skip right and terminate</TD>
</TR>
</TABLE>
The cursor is moved to the current end of line and the
line is terminated.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>CTRL_W</TD><TD ALIGN=CENTER>home</TD><TD ALIGN=CENTER>Skip left</TD>
</TR>
</TABLE>
The cursor is positioned at the left margin, i.e. column 1.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>CTRL_X</TD><TD ALIGN=CENTER>insert_tab</TD><TD ALIGN=CENTER>Insert tab</TD>
</TR>
</TABLE>
The character under the cursor is moved right to the next tab stop;
the gap is filled with blanks.
The cursor is not moved.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>CTRL_Y</TD><TD ALIGN=CENTER>kill_left</TD><TD ALIGN=CENTER>Kill left</TD>
</TR>
</TABLE>
All characters to the left of the cursor are erased; those at and
to the right of the cursor are moved to the left to fill the void.
The cursor is left in column 1.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>CTRL_Z</TD><TD ALIGN=CENTER>literal</TD><TD ALIGN=CENTER>Enter Literal</TD>
</TR>
</TABLE>
This key provides a means for entering
<B>se</B>'s
control characters literally as text into the file.
In fact,
any character that can be generated from the keyboard is
taken literally when it immediately follows this key.
If the character is non-printing (as are all of
<B>se</B>'s
control characters),
it appears on the screen as the current non-printing
replacement character (normally a blank).
<!--  The status of the case conversion indicator is inverted; -->
<!--  if case inversion was on, it is turned off, and vice versa. -->
<!--  Case inversion, when in effect, causes all upper case letters to -->
<!--  be converted to lower case, and all lower case letters to be -->
<!--  converted to upper case. -->
<!--  Note, however, that -->
<!--  .se -->
<!--  continues -->
<!--  to recognise alphabetic line numbers in upper case only, -->
<!--  in contrast to the &#147;case inversion&#148; option -->
<!--  (see the description of options above). -->
<!--  When case inversion is on, &#145;<TT>CASE</TT>&#146; appears in the status line. -->
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>CTRL__</TD><TD ALIGN=CENTER>insert_newline</TD><TD ALIGN=CENTER>Insert newline</TD>
</TR>
</TABLE>
When in append mode, a newline character is inserted before the
current cursor position, and the cursor is moved one position
to the right (the newline is displayed according to the current
non-printing replacement
character&nbsp;&#151;&nbsp;see the &#145;<TT>u</TT>&#146; option). 
When in overlay mode, the current line is split, at the cursor position,
into two lines and the cursor remains in its place.
.tc
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>CTRL_]</TD><TD ALIGN=CENTER>fix_screen</TD><TD ALIGN=CENTER>Fix screen</TD>
</TR>
</TABLE>
The screen is reconstructed from
<B>se</B>'s
internal representation of the screen.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>CTRL_\</TD><TD ALIGN=CENTER>g_tab_left</TD><TD ALIGN=CENTER>Tab left and erase</TD>
</TR>
</TABLE>
Characters are erased starting with the character at the nearest tab
stop to the left of the cursor up to but not including
the character under the cursor.
The rest of the line, including the cursor,
is moved to the left to close the gap.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>CTRL_^</TD><TD ALIGN=CENTER>g_tab_right</TD><TD ALIGN=CENTER>Tab right and erase</TD>
</TR>
</TABLE>
Characters are erased starting with the character under the cursor
up to but not including the character at the nearest tab stop to
the right of the cursor.
The rest of the line is then shifted to the left to close the gap.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>DELETE</TD><TD ALIGN=CENTER>kill_all</TD><TD ALIGN=CENTER>Kill all</TD>
</TR>
</TABLE>
The entire line is erased.
<!--  along with any error  -->
<!--  message that appears in the status line. -->
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>ESC</TD><TD ALIGN=CENTER></TD><TD ALIGN=CENTER>no function</TD>
</TR>
</TABLE>
The escape key is not bound to any function by default.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>unbound</TD><TD ALIGN=CENTER>top</TD><TD ALIGN=CENTER>Top of file</TD>
</TR>
</TABLE>
The current line is moved to the top of the file, i.e. line 1.
This is equivalent to typing &#145;<TT>1</TT>&#146; on the command line and
pressing the Enter key.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>unbound</TD><TD ALIGN=CENTER>bottom</TD><TD ALIGN=CENTER>Bottom of file</TD>
</TR>
</TABLE>
The current line is moved to the bottom of the file, i.e.
line &#145;<TT>$</TT>&#146;.
This is equivalent to typing &#145;<TT>$</TT>&#146; on the command line and
pressing the Enter key.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>unbound</TD><TD ALIGN=CENTER>scroll_down</TD><TD ALIGN=CENTER>Scroll Down</TD>
</TR>
</TABLE>
The effect of this key depends on
<B>se</B>'s
current mode.
When in command mode, the current line pointer is moved
to the next line without affecting the contents of the command line.
In overlay mode (viz. the &#145;<TT>v</TT>&#146; command), the cursor is
moved up down line while remaining in the same column.
In either case, the text is scrolled up so that the cursor stays
on the same physical row on the screen.
In append mode, this key is ignored.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>unbound</TD><TD ALIGN=CENTER>scroll_up</TD><TD ALIGN=CENTER>Scroll Up</TD>
</TR>
</TABLE>
The effect of this key depends on
<B>se</B>'s
current mode.
When in command mode, the current line pointer is moved
to the previous line without affecting the contents of the command line.
In overlay mode (viz. the &#145;<TT>v</TT>&#146; command), the cursor is
moved up one line while remaining in the same column.
In either case, the text is scrolled down so that the cursor stays
on the same physical row on the screen.
In append mode, this key is ignored.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>unbound</TD><TD ALIGN=CENTER>date</TD><TD ALIGN=CENTER>Enter Date</TD>
</TR>
</TABLE>
The current date appears at the cursor position as if the user had
typed it in.
The date is obtained from the system clock.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>unbound</TD><TD ALIGN=CENTER>time</TD><TD ALIGN=CENTER>Enter Time</TD>
</TR>
</TABLE>
The current time appears at the cursor position as if the user had
typed it in.
The time is obtained from the system clock.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>unbound</TD><TD ALIGN=CENTER>month</TD><TD ALIGN=CENTER>Enter Month</TD>
</TR>
</TABLE>
The name of the current month appears at the cursor position as if
the user had typed it in.
The date is obtained from the system clock.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>unbound</TD><TD ALIGN=CENTER>year2</TD><TD ALIGN=CENTER>Enter Two-digit Year</TD>
</TR>
</TABLE>
The current year appears at the cursor position as if the user had
typed it in.
The year will be abbreviated to a two-digit number, e.g. 1991 will
appear as &#145;<TT>91</TT>&#146;.
The year is obtained from the system clock.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>unbound</TD><TD ALIGN=CENTER>year4</TD><TD ALIGN=CENTER>Enter Four-digit Year</TD>
</TR>
</TABLE>
The current year appears at the cursor position as if the user had
typed it in.
The year will be entered in full as a four-digit number, e.g. 1991 will
appear as &#145;<TT>1991</TT>&#146;.
The year is obtained from the system clock.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>unbound</TD><TD ALIGN=CENTER>filename</TD><TD ALIGN=CENTER>Enter Current Filename</TD>
</TR>
</TABLE>
The current file name, as displayed on the status line, appears
at the cursor position as if the user had typed it in.
If there is no saved file name, nothing appears.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>unbound</TD><TD ALIGN=CENTER>hostname</TD><TD ALIGN=CENTER>Enter Current Hostname</TD>
</TR>
</TABLE>
The name of the host computer, as displayed by the &#145;<TT>l</TT>&#146; command,
appears at the cursor position as if the user had typed it in.
If there is no known host name, nothing appears.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>unbound</TD><TD ALIGN=CENTER>username</TD><TD ALIGN=CENTER>Enter Current Username</TD>
</TR>
</TABLE>
The login ID of the user
appears at the cursor position as if the user had typed it in.
If it is not possible to determine the user name, nothing appears.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>unbound</TD><TD ALIGN=CENTER>curln</TD><TD ALIGN=CENTER>Enter current line number</TD>
</TR>
</TABLE>
The number of the current line, i.e. the value of &#145;<TT>.</TT>&#146;,
appears at the cursor position as if the user had typed it in.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>unbound</TD><TD ALIGN=CENTER>topln</TD><TD ALIGN=CENTER>Enter top-of-screen line number</TD>
</TR>
</TABLE>
The number of the line at the top of the screen,
i.e. the value of &#145;<TT>#</TT>&#146;,
appears at the cursor position as if the user had typed it in.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>unbound</TD><TD ALIGN=CENTER>lastln</TD><TD ALIGN=CENTER>Enter end-of-file line number</TD>
</TR>
</TABLE>
The number of the last line in the file,
i.e. the value of &#145;<TT>$</TT>&#146;,
appears at the cursor position as if the user had typed it in.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>unbound</TD><TD ALIGN=CENTER>upper</TD><TD ALIGN=CENTER>Convert to Uppercase</TD>
</TR>
</TABLE>
If the cursor is positioned over a lower-case character,
it is converted to upper case.
Non-lower case characters are unaffected.
The cursor is not moved.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>unbound</TD><TD ALIGN=CENTER>lower</TD><TD ALIGN=CENTER>Convert to Lowercase</TD>
</TR>
</TABLE>
If the cursor is positioned over an upper-case character,
it is converted to lower case.
Non-upper case characters are unaffected.
The cursor is not moved.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>unbound</TD><TD ALIGN=CENTER>ascii</TD><TD ALIGN=CENTER>Display ASCII code</TD>
</TR>
</TABLE>
The ASCII code for the current character is displayed in hexadecimal
on the status line.
If the cursor is positioned at the end of a line, the word
&#145;<TT>NEWLINE</TT>&#146; is displayed; this is because some operating systems
use a multi-character sequence to represent line breaks and
<B>se</B>
regards this as a single, special character internally.
The cursor is not moved by this function.
See also the &#145;<TT>ou</TT>&#146; option if you need to see unprintable
characters on
<B>se</B>'s
display.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>unbound</TD><TD ALIGN=CENTER>first_char</TD><TD ALIGN=CENTER>First Character in Line</TD>
</TR>
</TABLE>
The cursor is positioned on the first non-blank character of the line.
If there are no non-blank characters on the line, the effect is the
same as &#145;<TT>home</TT>&#146;, i.e. the cursor moves to the left margin.
This function is useful as an alternative to &#145;<TT>home</TT>&#146; when
<B>se</B>
is in auto-indent mode.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>unbound</TD><TD ALIGN=CENTER>last_char</TD><TD ALIGN=CENTER>Last Character in Line</TD>
</TR>
</TABLE>
The cursor is positioned on the last non-blank character of the line.
If there are no non-blank characters on the line, the effect is the
same as &#145;<TT>end</TT>&#146;, i.e. the cursor moves to the right-hand end
of the line.
<!--  -->
<P>
<TABLE BORDER COLS=3>
<TR>
<TD ALIGN=CENTER>unbound</TD><TD ALIGN=CENTER>nop</TD><TD ALIGN=CENTER>No Operation</TD>
</TR>
</TABLE>
This function has no effect.
It is useful whenever a key needs to be completely disabled.
Note that it is not a good idea to disable the return key...
<BR>

Since
<B>se</B>
takes its commands directly from the
terminal,
it cannot be run from a script by using
Shell
I/O redirection, and
Unix
erase, kill, and escape conventions do not exactly apply.
(If you want to run
<B>se</B>
from a script, see the documentation for the &#145;<TT>oo</TT>&#146; option.)
</BODY></HTML>
